<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DoScript Visual IDE â€” Complete v0.6.5</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #fff;
        }

        #app { display:flex; height:100vh; width:100vw; }

        /* Sidebar */
        #sidebar { width:300px; background:#2a2a2a; border-right:1px solid #444; display:flex; flex-direction:column; }
        #sidebar-header { padding:14px 16px; border-bottom:1px solid #444; }
        #sidebar-header h2 { font-size:15px; font-weight:600; color:#fff; }
        #search-box { padding:8px 12px; border-bottom:1px solid #333; }
        #search-input { width:100%; padding:8px 10px; background:#1a1a1a; border:1px solid #444; border-radius:4px; color:#fff; font-size:12px; }
        #search-input::placeholder { color:#666; }
        #commands-list { flex:1; overflow-y:auto; }
        .category { padding:10px 12px; border-bottom:1px solid #333; }
        .category h3 { color:#888; font-size:10px; text-transform:uppercase; margin-bottom:6px; font-weight:600; letter-spacing:0.5px; }
        .cmd-button { width:100%; padding:8px 10px; margin-bottom:3px; background:#333; border:none; border-left:3px solid; border-radius:4px; color:#fff; text-align:left; cursor:pointer; transition:background .15s; }
        .cmd-button:hover { background:#3d3d3d; }
        .cmd-name { font-weight:500; font-size:12px; }
        .cmd-desc { font-size:10px; color:#888; margin-top:1px; }

        /* Main */
        #main { flex:1; display:flex; flex-direction:column; min-width:0; }

        #toolbar { background:#2a2a2a; border-bottom:1px solid #444; padding:10px 12px; display:flex; gap:6px; align-items:center; }
        .btn { padding:7px 13px; border:none; border-radius:4px; color:#fff; font-size:12px; cursor:pointer; transition:opacity .2s; white-space:nowrap; }
        .btn:hover { opacity:.85; }
        .btn-primary { background:#3b82f6; }
        .btn-success { background:#10b981; }
        .btn-purple { background:#8b5cf6; }
        .btn-secondary { background:#444; }
        .btn-danger { background:#ef4444; }
        .spacer { flex:1; }
        .hint { color:#555; font-size:11px; margin-left:8px; }
        .zoom-info { color:#aaa; font-size:12px; margin-left:4px; min-width:42px; text-align:center; }

        #canvas-wrapper { flex:1; position:relative; overflow:hidden; background:#1a1a1a; }
        #canvas-wrapper.panning { cursor:grabbing; }
        #grid { position:absolute; top:0; left:0; width:100%; height:100%; background-image: linear-gradient(rgba(255,255,255,.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,.03) 1px, transparent 1px); background-size:20px 20px; }

        #svg-layer { position:absolute; top:0; left:0; width:100%; height:100%; z-index:1; pointer-events:auto; overflow:visible; }
        #nodes-layer { position:absolute; top:0; left:0; z-index:2; }

        .node { position:absolute; min-width:200px; max-width:240px; background:#2a2a2a; border:2px solid #444; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,.5); cursor:move; user-select:none; touch-action:none; }
        .node.selected { border-color:#3b82f6; box-shadow:0 0 0 2px rgba(59,130,246,.3); }
        .node-header { padding:9px 10px; border-radius:6px 6px 0 0; display:flex; justify-content:space-between; align-items:center; gap:8px; touch-action:none; }
        .node-title-input { flex:1; background:transparent; border:1px solid transparent; color:#fff; font-weight:600; font-size:12px; padding:2px 4px; border-radius:3px; outline:none; }
        .node-title-input:not([readonly]):hover { background: rgba(255,255,255,0.1); }
        .node-title-input:focus { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.3); }
        .node-delete-btn { background:rgba(255,255,255,0.2); border:none; color:#fff; padding:3px 7px; border-radius:3px; cursor:pointer; font-size:11px; flex-shrink:0; }
        .node-delete-btn:hover { background:rgba(255,255,255,0.35); }
        .node-body { padding:10px; }
        .input-row { display:flex; align-items:center; gap:6px; margin-bottom:6px; }
        .port-in { width:13px; height:13px; border-radius:50%; background:#fbbf24; border:2px solid #1a1a1a; cursor:pointer; flex-shrink:0; transition:transform .1s; }
        .port-in:hover { transform:scale(1.3); box-shadow:0 0 8px rgba(251,191,36,.6); }
        .node-input { flex:1; background:#1a1a1a; border:1px solid #444; color:#fff; padding:5px 7px; border-radius:4px; font-size:11px; }
        .node-input::placeholder { color:#666; }
        .node-input:focus { outline:none; border-color:#3b82f6; }
        .node-outputs { border-top:1px solid #444; padding:10px; }
        .output-row { display:flex; align-items:center; justify-content:flex-end; gap:6px; margin-bottom:5px; }
        .output-label { color:#aaa; font-size:10px; }
        .port-out { width:13px; height:13px; border-radius:50%; background:#3b82f6; border:2px solid #1a1a1a; cursor:pointer; flex-shrink:0; transition:transform .1s; }
        .port-out:hover { transform:scale(1.3); box-shadow:0 0 8px rgba(59,130,246,.6); }
        .port-out.exec { background:#10b981; }
        .port-out.exec:hover { box-shadow:0 0 8px rgba(16,185,129,.6); }

        .connection { stroke:#6366f1; stroke-width:4; fill:none; cursor:pointer; pointer-events:auto; stroke-linecap:round; transition:all .15s; }
        .connection:hover { stroke:#ef4444; stroke-width:6; filter:drop-shadow(0 0 6px rgba(239,68,68,.8)); }
        .temp-connection { stroke:#818cf8; stroke-width:3; fill:none; stroke-dasharray:6,4; pointer-events:none; }

        #code-panel { height:240px; background:#2a2a2a; border-top:1px solid #444; display:none; flex-direction:column; }
        #code-panel.visible { display:flex; }
        #code-header { padding:10px 12px; border-bottom:1px solid #444; display:flex; justify-content:space-between; align-items:center; }
        #code-header h3 { font-size:13px; font-weight:600; }
        #code-close { background:none; border:none; color:#aaa; font-size:20px; cursor:pointer; padding:0 6px; }
        #code-content { flex:1; overflow:auto; padding:10px 12px; }
        #code-content pre { color:#4ade80; font-family:'Courier New', monospace; font-size:12px; line-height:1.5; }

        #drop-overlay { display:none; position:absolute; inset:0; background:rgba(59,130,246,0.12); border:3px dashed #3b82f6; border-radius:6px; z-index:999; align-items:center; justify-content:center; pointer-events:none; }
        #drop-overlay.active { display:flex; }
        #drop-text { color:#3b82f6; font-size:22px; font-weight:700; text-shadow:0 2px 8px rgba(0,0,0,.7); }

        #toast { position:fixed; bottom:24px; left:50%; transform:translateX(-50%); background:#1e293b; color:#fff; border:1px solid #334155; border-radius:8px; padding:10px 20px; font-size:13px; z-index:9999; opacity:0; transition:opacity .3s; pointer-events:none; }
        #toast.show { opacity:1; }

        #tooltip { position:fixed; background:rgba(239,68,68,.95); color:white; padding:6px 12px; border-radius:6px; font-size:11px; font-weight:600; pointer-events:none; z-index:10000; opacity:0; transition:opacity .2s; }
        #tooltip.show { opacity:1; }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <div id="sidebar-header"><h2>Command Library v0.6.5</h2></div>
            <div id="search-box"><input id="search-input" placeholder="ðŸ” Search commands..." /></div>
            <div id="commands-list"></div>
        </div>

        <div id="main">
            <div id="toolbar">
                <button class="btn btn-primary" id="btn-toggle-sidebar">â˜° Library</button>
                <button class="btn btn-success" id="btn-generate">â–¶ Generate</button>
                <button class="btn btn-purple" id="btn-download">â¬‡ Download .do</button>
                <button class="btn btn-primary" id="btn-load">ðŸ“‚ Load .do</button>
                <input id="file-input" type="file" accept=".do,.txt" style="display:none" />
                <button class="btn btn-secondary" id="btn-clear">ðŸ—‘ Clear</button>
                <button class="btn btn-secondary" id="btn-reset-view">âŒ– Reset View</button>
                <div class="spacer"></div>
                <button class="btn btn-secondary" id="btn-zoom-out">âˆ’</button>
                <span class="zoom-info" id="zoom-display">100%</span>
                <button class="btn btn-secondary" id="btn-zoom-in">+</button>
                <span class="hint">ðŸ’¡ ESC or Right-click to cancel connections â€¢ Click connections to delete â€¢ Double-click titles to edit</span>
            </div>

            <div id="canvas-wrapper">
                <div id="grid"></div>
                <svg id="svg-layer"></svg>
                <div id="nodes-layer"></div>
                <div id="drop-overlay"><div id="drop-text">Drop .do file here</div></div>
            </div>

            <div id="code-panel">
                <div id="code-header"><h3>Generated DoScript Code</h3><button id="code-close">Ã—</button></div>
                <div id="code-content"><pre id="code-text"></pre></div>
            </div>
        </div>
    </div>

    <div id="toast"></div>
    <div id="tooltip">Click to delete</div>

    <script>
        // --- Full command list with ALL features from doscript.py v0.6.5
        const COMMANDS = {
            'Output & Input': [
                { name: 'say', desc: 'Print a message', inputs: ['message'], outputs: ['exec'], color: '#8b5cf6', defaultValues: {message: '"Hello"'} },
                { name: 'log', desc: '[INFO] log message', inputs: ['message'], outputs: ['exec'], color: '#8b5cf6', defaultValues: {message: '"Info message"'} },
                { name: 'warn', desc: '[WARN] log message', inputs: ['message'], outputs: ['exec'], color: '#f59e0b', defaultValues: {message: '"Warning"'} },
                { name: 'error', desc: '[ERROR] log message', inputs: ['message'], outputs: ['exec'], color: '#ef4444', defaultValues: {message: '"Error occurred"'} },
                { name: 'ask', desc: 'Prompt user for input', inputs: ['variable', 'prompt'], outputs: ['exec'], color: '#8b5cf6', defaultValues: {variable: 'answer', prompt: '"Enter value:"'} },
                { name: 'pause', desc: 'Wait for Enter key', inputs: [], outputs: ['exec'], color: '#6366f1' },
                { name: 'input', desc: 'Read a line into a variable', inputs: ['variable', 'prompt'], outputs: ['exec'], color: '#8b5cf6', defaultValues: {variable: 'userInput', prompt: '"Enter:"'} }
            ],
            'Variables': [
                { name: 'global_variable', desc: 'Declare global variable(s)', inputs: ['names'], outputs: ['exec'], color: '#14b8a6', defaultValues: {names: 'myVar'} },
                { name: 'local_variable', desc: 'Declare local variable(s)', inputs: ['names'], outputs: ['exec'], color: '#14b8a6', defaultValues: {names: 'localVar'} },
                { name: 'set', desc: 'variable = value', inputs: ['variable', 'value'], outputs: ['exec'], color: '#14b8a6', defaultValues: {variable: 'x', value: '10'} },
                { name: 'incr', desc: 'Increment variable', inputs: ['variable', 'amount'], outputs: ['exec'], color: '#14b8a6', defaultValues: {variable: 'counter', amount: '1'} },
                { name: 'decr', desc: 'Decrement variable', inputs: ['variable', 'amount'], outputs: ['exec'], color: '#14b8a6', defaultValues: {variable: 'counter', amount: '1'} },
                { name: 'copy', desc: 'Copy variable', inputs: ['src', 'dst'], outputs: ['exec'], color: '#14b8a6', defaultValues: {src: 'source', dst: 'dest'} }
            ],
            'Flow Control': [
                { name: 'if', desc: 'If condition', inputs: ['condition'], outputs: ['exec'], color: '#f97316', defaultValues: {condition: 'x > 0'} },
                { name: 'elif', desc: 'Else if condition', inputs: ['condition'], outputs: ['exec'], color: '#f97316', defaultValues: {condition: 'x < 0'} },
                { name: 'else', desc: 'Else block', inputs: [], outputs: ['exec'], color: '#f97316' },
                { name: 'end_if', desc: 'End if block', inputs: [], outputs: ['exec'], color: '#f97316' },
                { name: 'goto', desc: 'Jump to label', inputs: ['label'], outputs: ['exec'], color: '#f97316', defaultValues: {label: 'myLabel'} },
                { name: 'label', desc: 'Create label', inputs: ['name'], outputs: ['exec'], color: '#64748b', defaultValues: {name: 'myLabel'} },
            ],
            'Loops': [
                { name: 'for_each', desc: 'Loop through list/files', inputs: ['var', 'items'], outputs: ['exec'], color: '#06b6d4', defaultValues: {var: 'item', items: 'myList'} },
                { name: 'for_each_line', desc: 'Loop through file lines', inputs: ['var', 'file'], outputs: ['exec'], color: '#06b6d4', defaultValues: {var: 'line', file: '"data.txt"'} },
                { name: 'end_for', desc: 'End for_each', inputs: [], outputs: ['exec'], color: '#06b6d4' },
                { name: 'while', desc: 'While loop', inputs: ['condition'], outputs: ['exec'], color: '#06b6d4', defaultValues: {condition: 'x < 10'} },
                { name: 'end_while', desc: 'End while', inputs: [], outputs: ['exec'], color: '#06b6d4' },
                { name: 'repeat', desc: 'Repeat N times', inputs: ['count'], outputs: ['exec'], color: '#06b6d4', defaultValues: {count: '5'} },
                { name: 'loop', desc: 'Loop forever or N times', inputs: ['expr'], outputs: ['exec'], color: '#06b6d4', defaultValues: {expr: 'forever'} },
                { name: 'end_loop', desc: 'End loop block', inputs: [], outputs: ['exec'], color: '#06b6d4' },
                { name: 'break', desc: 'Break loop', inputs: [], outputs: ['exec'], color: '#ef4444' },
                { name: 'continue', desc: 'Continue loop', inputs: [], outputs: ['exec'], color: '#f59e0b' }
            ],
            'Functions': [
                { name: 'function', desc: 'Define function', inputs: ['name'], outputs: ['exec'], color: '#7c3aed', defaultValues: {name: 'myFunction'} },
                { name: 'end_function', desc: 'End function', inputs: [], outputs: ['exec'], color: '#7c3aed' },
                { name: 'call', desc: 'Call function', inputs: ['name', 'args'], outputs: ['exec'], color: '#7c3aed', defaultValues: {name: 'myFunction', args: ''} },
                { name: 'return', desc: 'Return from function', inputs: ['value'], outputs: ['exec'], color: '#7c3aed', defaultValues: {value: ''} }
            ],
            'File System': [
                { name: 'make file', desc: 'Create file', inputs: ['path', 'content'], outputs: ['exec'], color: '#16a34a', defaultValues: {path: '"output.txt"', content: '"Hello"'} },
                { name: 'make folder', desc: 'Create folder/directory', inputs: ['path'], outputs: ['exec'], color: '#16a34a', defaultValues: {path: '"new_folder"'} },
                { name: 'delete', desc: 'Delete file/folder', inputs: ['path'], outputs: ['exec'], color: '#ef4444', defaultValues: {path: '"temp.txt"'} },
                { name: 'rename', desc: 'Rename file', inputs: ['old', 'new'], outputs: ['exec'], color: '#f97316', defaultValues: {old: '"old.txt"', new: '"new.txt"'} },
                { name: 'copy', desc: 'Copy file', inputs: ['src', 'dst'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {src: '"source.txt"', dst: '"backup.txt"'} },
                { name: 'move', desc: 'Move file', inputs: ['src', 'dst'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {src: '"file.txt"', dst: '"archive/"'} },
                { name: 'read', desc: 'Read file into var', inputs: ['path', 'var'], outputs: ['exec'], color: '#64748b', defaultValues: {path: '"data.txt"', var: 'content'} },
                { name: 'write', desc: 'Write text to file', inputs: ['path', 'text'], outputs: ['exec'], color: '#16a34a', defaultValues: {path: '"output.txt"', text: '"Hello"'} },
                { name: 'append', desc: 'Append text to file', inputs: ['path', 'text'], outputs: ['exec'], color: '#16a34a', defaultValues: {path: '"log.txt"', text: '"New line"'} },
                { name: 'exists', desc: 'Check path exists', inputs: ['path'], outputs: ['exec'], color: '#64748b', defaultValues: {path: '"file.txt"'} },
                { name: 'list_dir', desc: 'List directory', inputs: ['path', 'var'], outputs: ['exec'], color: '#06b6d4', defaultValues: {path: '"."', var: 'files'} },
                { name: 'replace_in_file', desc: 'Replace text in file', inputs: ['path', 'find', 'replace'], outputs: ['exec'], color: '#f59e0b', defaultValues: {path: '"file.txt"', find: '"old"', replace: '"new"'} },
                { name: 'replace_regex_in_file', desc: 'Regex replace in file', inputs: ['path', 'pattern', 'replace'], outputs: ['exec'], color: '#f59e0b', defaultValues: {path: '"file.txt"', pattern: '"\\d+"', replace: '"X"'} },
            ],
            'JSON Operations': [
                { name: 'json_read', desc: 'Read JSON file', inputs: ['path', 'var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {path: '"data.json"', var: 'jsonData'} },
                { name: 'json_write', desc: 'Write JSON to file', inputs: ['path', 'var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {path: '"output.json"', var: 'jsonData'} },
                { name: 'json_get', desc: 'Get JSON key value', inputs: ['var', 'key', 'result'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {var: 'jsonData', key: '"name"', result: 'value'} }
            ],
            'CSV Operations': [
                { name: 'csv_read', desc: 'Read CSV file', inputs: ['path', 'var'], outputs: ['exec'], color: '#10b981', defaultValues: {path: '"data.csv"', var: 'csvData'} },
                { name: 'csv_write', desc: 'Write CSV to file', inputs: ['path', 'var'], outputs: ['exec'], color: '#10b981', defaultValues: {path: '"output.csv"', var: 'csvData'} },
                { name: 'csv_get', desc: 'Get CSV cell', inputs: ['var', 'row', 'col', 'result'], outputs: ['exec'], color: '#10b981', defaultValues: {var: 'csvData', row: '0', col: '0', result: 'value'} }
            ],
            'Archive Operations': [
                { name: 'zip', desc: 'Create ZIP archive', inputs: ['source', 'zipfile'], outputs: ['exec'], color: '#8b5cf6', defaultValues: {source: '"folder"', zipfile: '"archive.zip"'} },
                { name: 'unzip', desc: 'Extract ZIP archive', inputs: ['zipfile', 'dest'], outputs: ['exec'], color: '#8b5cf6', defaultValues: {zipfile: '"archive.zip"', dest: '"extracted"'} },
                { name: 'zip_list', desc: 'List ZIP contents', inputs: ['zipfile', 'var'], outputs: ['exec'], color: '#8b5cf6', defaultValues: {zipfile: '"archive.zip"', var: 'files'} }
            ],
            'System & Shell': [
                { name: 'run', desc: 'Run program/macro', inputs: ['cmd'], outputs: ['exec'], color: '#ef4444', defaultValues: {cmd: '"notepad.exe"'} },
                { name: 'execute', desc: 'Execute .exe file', inputs: ['path'], outputs: ['exec'], color: '#ef4444', defaultValues: {path: '"program.exe"'} },
                { name: 'shell', desc: 'Run shell command', inputs: ['cmd'], outputs: ['exec'], color: '#ef4444', defaultValues: {cmd: '"dir"'} },
                { name: 'capture', desc: 'Capture command output', inputs: ['cmd', 'var'], outputs: ['exec'], color: '#64748b', defaultValues: {cmd: '"dir"', var: 'output'} },
                { name: 'wait', desc: 'Sleep N seconds', inputs: ['seconds'], outputs: ['exec'], color: '#64748b', defaultValues: {seconds: '1'} },
                { name: 'exit', desc: 'Exit script', inputs: ['code'], outputs: [], color: '#ef4444', defaultValues: {code: '0'} },
                { name: 'kill', desc: 'Kill process by name', inputs: ['process'], outputs: ['exec'], color: '#ef4444', defaultValues: {process: '"notepad.exe"'} },
                { name: 'shutdown', desc: 'Shutdown Windows', inputs: ['delay'], outputs: ['exec'], color: '#ef4444', defaultValues: {delay: '60'} },
                { name: 'open', desc: 'Open file/folder', inputs: ['path'], outputs: ['exec'], color: '#10b981', defaultValues: {path: '"."'} },
                { name: 'open_link', desc: 'Open URL in browser', inputs: ['url'], outputs: ['exec'], color: '#10b981', defaultValues: {url: '"https://example.com"'} },
                { name: 'do_new', desc: 'Execute new DoScript', inputs: ['script', 'args'], outputs: ['exec'], color: '#7c3aed', defaultValues: {script: '"script.do"', args: ''} },
                { name: 'include', desc: 'Include another script', inputs: ['path'], outputs: ['exec'], color: '#7c3aed', defaultValues: {path: '"library.do"'} }
            ],
            'System Info': [
                { name: 'system_cpu', desc: 'Get CPU usage %', inputs: ['var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {var: 'cpuUsage'} },
                { name: 'system_memory', desc: 'Get memory usage %', inputs: ['var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {var: 'memUsage'} },
                { name: 'system_disk', desc: 'Get disk usage %', inputs: ['path', 'var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {path: '"C:\\\\"', var: 'diskUsage'} }
            ],
            'PATH Management': [
                { name: 'path_add', desc: 'Add to system PATH', inputs: ['path', 'scope'], outputs: ['exec'], color: '#f59e0b', defaultValues: {path: '"C:\\\\MyApp"', scope: '--user'} },
                { name: 'path_remove', desc: 'Remove from PATH', inputs: ['path', 'scope'], outputs: ['exec'], color: '#f59e0b', defaultValues: {path: '"C:\\\\MyApp"', scope: '--user'} },
                { name: 'script_path_add', desc: 'Add to script path', inputs: ['path'], outputs: ['exec'], color: '#f59e0b', defaultValues: {path: '"./libs"'} },
                { name: 'script_path_remove', desc: 'Remove from script path', inputs: ['path'], outputs: ['exec'], color: '#f59e0b', defaultValues: {path: '"./libs"'} }
            ],
            'Networking': [
                { name: 'download', desc: 'Download file from URL', inputs: ['url', 'path'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {url: '"https://example.com/file.zip"', path: '"download.zip"'} },
                { name: 'upload', desc: 'Upload file to URL', inputs: ['path', 'url'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {path: '"file.txt"', url: '"https://example.com/upload"'} },
                { name: 'ping', desc: 'Ping a host', inputs: ['host'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {host: '"google.com"'} },
                { name: 'http_get', desc: 'HTTP GET request', inputs: ['url', 'var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {url: '"https://api.example.com"', var: 'response'} },
                { name: 'http_post', desc: 'HTTP POST request', inputs: ['url', 'body', 'var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {url: '"https://api.example.com"', body: '"{}"', var: 'response'} },
                { name: 'http_put', desc: 'HTTP PUT request', inputs: ['url', 'body', 'var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {url: '"https://api.example.com"', body: '"{}"', var: 'response'} },
                { name: 'http_delete', desc: 'HTTP DELETE request', inputs: ['url', 'var'], outputs: ['exec'], color: '#0ea5e9', defaultValues: {url: '"https://api.example.com/item/1"', var: 'response'} }
            ],
            'Random': [
                { name: 'random_number', desc: 'Generate random number', inputs: ['min', 'max', 'var'], outputs: ['exec'], color: '#f59e0b', defaultValues: {min: '1', max: '100', var: 'randomNum'} },
                { name: 'random_string', desc: 'Generate random string', inputs: ['length', 'var'], outputs: ['exec'], color: '#f59e0b', defaultValues: {length: '10', var: 'randomStr'} },
                { name: 'random_choice', desc: 'Pick random item', inputs: ['list', 'var'], outputs: ['exec'], color: '#f59e0b', defaultValues: {list: 'myList', var: 'choice'} }
            ],
            'Utilities': [
                { name: 'concat', desc: 'Concatenate strings', inputs: ['out', 'a', 'b'], outputs: ['exec'], color: '#64748b', defaultValues: {out: 'result', a: '"Hello"', b: '" World"'} },
                { name: 'split', desc: 'Split string', inputs: ['out', 'str', 'sep'], outputs: ['exec'], color: '#64748b', defaultValues: {out: 'parts', str: '"a,b,c"', sep: '","'} },
                { name: 'replace', desc: 'Replace in string', inputs: ['out', 'str', 'from', 'to'], outputs: ['exec'], color: '#64748b', defaultValues: {out: 'result', str: '"hello"', from: '"h"', to: '"H"'} }
            ],
            'Arithmetic': [
                { name: 'add',      desc: 'result = a + b',   inputs: ['result', 'a', 'b'], outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x', b: 'y'} },
                { name: 'sub',      desc: 'result = a - b',   inputs: ['result', 'a', 'b'], outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x', b: 'y'} },
                { name: 'mul',      desc: 'result = a * b',   inputs: ['result', 'a', 'b'], outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x', b: 'y'} },
                { name: 'div',      desc: 'result = a / b',   inputs: ['result', 'a', 'b'], outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x', b: 'y'} },
                { name: 'floordiv', desc: 'result = a // b',  inputs: ['result', 'a', 'b'], outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x', b: 'y'} },
                { name: 'mod',      desc: 'result = a % b',   inputs: ['result', 'a', 'b'], outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x', b: 'y'} },
                { name: 'pow',      desc: 'result = a ** b',  inputs: ['result', 'a', 'b'], outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x', b: 'y'} },
                { name: 'neg',      desc: 'result = -a',      inputs: ['result', 'a'],       outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x'} },
                { name: 'abs',      desc: 'result = abs(a)',  inputs: ['result', 'a'],       outputs: ['exec'], color: '#e879f9', defaultValues: {result: 'res', a: 'x'} }
            ]
        };

        // --- state with Start node
        const state = {
            nodes: [
                { id: 1, type: 'start', x: 80, y: 80, color: '#10b981', inputs: {}, outputs: ['exec'] }
            ],
            connections: [],
            nextId: 2,
            selectedNode: null,
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            panStartX: 0,
            panStartY: 0,
            isDragging: false,
            dragNodeId: null,
            dragPointerId: null,
            dragStartClientX: 0,
            dragStartClientY: 0,
            dragNodeStartX: 0,
            dragNodeStartY: 0,
            isConnecting: false,
            connectFromNode: null,
            connectFromPort: null,
            connectPointerId: null,
            tempConnectX: 0,
            tempConnectY: 0,
        };

        // utilities
        function showToast(msg, isError = false) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.style.background = isError ? '#7f1d1d' : '#1e293b';
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        function renderSidebar(filter = '') {
            const list = document.getElementById('commands-list');
            list.innerHTML = '';
            const lower = filter.toLowerCase();
            for (const [category, cmds] of Object.entries(COMMANDS)) {
                const filtered = cmds.filter(c => c.name.toLowerCase().includes(lower) || c.desc.toLowerCase().includes(lower));
                if (filtered.length === 0) continue;
                const catDiv = document.createElement('div'); catDiv.className='category';
                const title = document.createElement('h3'); title.textContent = category; catDiv.appendChild(title);
                filtered.forEach(cmd => {
                    const btn = document.createElement('button'); btn.className='cmd-button';
                    btn.style.borderColor = cmd.color;
                    btn.innerHTML = `<div class="cmd-name">${cmd.name}</div><div class="cmd-desc">${cmd.desc}</div>`;
                    btn.addEventListener('click', () => {
                        const canvasRect = document.getElementById('canvas-wrapper').getBoundingClientRect();
                        const cx = (canvasRect.width/2 - state.panX)/state.zoom;
                        const cy = (canvasRect.height/2 - state.panY)/state.zoom;
                        
                        // Build inputs object with default values
                        const inputs = {};
                        if (cmd.inputs && cmd.inputs.length > 0) {
                            cmd.inputs.forEach(key => {
                                inputs[key] = (cmd.defaultValues && cmd.defaultValues[key]) ? cmd.defaultValues[key] : '';
                            });
                        }
                        
                        state.nodes.push({
                            id: state.nextId++,
                            type: cmd.name,
                            x: cx,
                            y: cy,
                            color: cmd.color,
                            inputs: inputs,
                            outputs: cmd.outputs || []
                        });
                        render();
                    });
                    catDiv.appendChild(btn);
                });
                list.appendChild(catDiv);
            }
        }

        function applyTransform(el) {
            el.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
            el.style.transformOrigin = '0 0';
        }

        function deleteNode(id) {
            const isStart = state.nodes.some(n => n.id===id && n.type==='start');
            if (isStart) { showToast('âœ‹ Start node cannot be deleted', true); return; }
            state.nodes = state.nodes.filter(n=>n.id!==id);
            state.connections = state.connections.filter(c=>c.from!==id && c.to!==id);
            if (state.selectedNode===id) state.selectedNode=null;
            render();
        }

        function deleteConnection(id) {
            state.connections = state.connections.filter(c=>c.id!==id);
            render();
        }

        function renderNodes() {
            const container = document.getElementById('nodes-layer');
            container.innerHTML = '';
            applyTransform(container);

            state.nodes.forEach(node => {
                const nodeEl = document.createElement('div'); nodeEl.className='node';
                nodeEl.dataset.nodeId = node.id; // Add node ID for easy lookup
                if (state.selectedNode===node.id) nodeEl.classList.add('selected');
                nodeEl.style.left = node.x + 'px'; nodeEl.style.top = node.y + 'px';

                const header = document.createElement('div'); header.className='node-header';
                header.style.backgroundColor = node.color; header.style.touchAction='none';

                const arithLabels = { 'add': '+ Add', 'sub': 'âˆ’ Subtract', 'mul': 'Ã— Multiply', 'div': 'Ã· Divide', 'floordiv': '// Floor Div', 'mod': '% Modulo', 'pow': '** Power', 'neg': 'âˆ’ Negate', 'abs': 'abs()' };
                const titleInput = document.createElement('input'); titleInput.type='text'; titleInput.className='node-title-input';
                titleInput.value = node.type === 'start' ? 'â–¶ Start' : (arithLabels[node.type] || node.type);
                titleInput.readOnly = node.type === 'start' || ['add','sub','mul','div','floordiv','mod','pow','neg','abs'].includes(node.type);

                if (node.type !== 'start' && !['add','sub','mul','div','floordiv','mod','pow','neg','abs'].includes(node.type)) {
                    let clickCount=0, clickTimer=null;
                    titleInput.addEventListener('click', (e) => {
                        e.stopPropagation(); clickCount++;
                        if (clickCount===1) clickTimer = setTimeout(()=>{clickCount=0;},300);
                        else if (clickCount===2){ clearTimeout(clickTimer); clickCount=0; titleInput.readOnly=false; titleInput.focus(); titleInput.select(); }
                    });
                    titleInput.addEventListener('blur', ()=>{ titleInput.readOnly=true; const newValue = titleInput.value.trim(); if (newValue) node.type=newValue; else titleInput.value=node.type; });
                    titleInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter') titleInput.blur(); else if (e.key==='Escape'){ titleInput.value=node.type; titleInput.blur(); } });
                }

                header.appendChild(titleInput);

                if (node.type !== 'start') {
                    const deleteBtn = document.createElement('button'); deleteBtn.className='node-delete-btn'; deleteBtn.textContent='Ã—';
                    deleteBtn.addEventListener('click', (e)=>{ e.stopPropagation(); deleteNode(node.id); });
                    header.appendChild(deleteBtn);
                }

                // drag via header
                header.addEventListener('pointerdown', (e)=>{
                    if (e.target.closest && e.target.closest('.node-delete-btn')) return;
                    if (e.target === titleInput && !titleInput.readOnly) return;
                    e.stopPropagation(); e.preventDefault();
                    state.isDragging = true; state.dragNodeId = node.id; state.dragPointerId = e.pointerId;
                    state.dragStartClientX = e.clientX; state.dragStartClientY = e.clientY;
                    state.dragNodeStartX = node.x; state.dragNodeStartY = node.y;
                    state.selectedNode = node.id; render();
                    try { header.setPointerCapture(e.pointerId); } catch(_) {}
                });
                header.addEventListener('pointerup', (e)=>{ try{ header.releasePointerCapture(e.pointerId);}catch(_){} });

                nodeEl.appendChild(header);

                // Special handling: nodes with outputs but no inputs get an exec input port
                const needsExecInput = node.outputs && node.outputs.length > 0 && Object.keys(node.inputs).length === 0 && node.type !== 'start';
                if (needsExecInput) {
                    const execInDiv = document.createElement('div'); 
                    execInDiv.className = 'input-row';
                    const execPort = document.createElement('div');
                    execPort.className = 'port-in';
                    execPort.addEventListener('pointerdown', (e) => startConnection(e, node.id, 'exec', true));
                    const execLabel = document.createElement('span');
                    execLabel.textContent = 'exec';
                    execLabel.style.fontSize = '10px';
                    execLabel.style.color = '#888';
                    execInDiv.appendChild(execPort);
                    execInDiv.appendChild(execLabel);
                    const bodyDiv = document.createElement('div');
                    bodyDiv.className = 'node-body';
                    bodyDiv.appendChild(execInDiv);
                    nodeEl.appendChild(bodyDiv);
                } else if (node.inputs && Object.keys(node.inputs).length > 0) {
                    const bodyDiv = document.createElement('div'); bodyDiv.className='node-body';
                    for (const [key, val] of Object.entries(node.inputs)) {
                        const row = document.createElement('div'); row.className='input-row';
                        const portIn = document.createElement('div'); portIn.className='port-in';
                        portIn.addEventListener('pointerdown', (e)=>startConnection(e, node.id, key, true));
                        const inp = document.createElement('input'); inp.type='text'; inp.className='node-input';
                        inp.placeholder = key; inp.value = val || '';
                        inp.addEventListener('input', (e)=>{ node.inputs[key] = e.target.value; });
                        row.appendChild(portIn); row.appendChild(inp);
                        bodyDiv.appendChild(row);
                    }
                    nodeEl.appendChild(bodyDiv);
                }

                if (node.outputs && node.outputs.length > 0) {
                    const outDiv = document.createElement('div'); outDiv.className='node-outputs';
                    node.outputs.forEach(out => {
                        const row = document.createElement('div'); row.className='output-row';
                        const lbl = document.createElement('span'); lbl.className='output-label'; lbl.textContent=out;
                        const portOut = document.createElement('div'); portOut.className='port-out';
                        if (out==='exec') portOut.classList.add('exec');
                        portOut.addEventListener('pointerdown', (e)=>startConnection(e, node.id, out, false));
                        row.appendChild(lbl); row.appendChild(portOut);
                        outDiv.appendChild(row);
                    });
                    nodeEl.appendChild(outDiv);
                }

                container.appendChild(nodeEl);
            });
        }

        function renderConnections() {
            const svg = document.getElementById('svg-layer');
            svg.innerHTML = '';
            state.connections.forEach(conn => {
                const from = state.nodes.find(n=>n.id===conn.from);
                const to = state.nodes.find(n=>n.id===conn.to);
                if (!from || !to) return;
                const fromPort = getPortPosition(from, conn.fromPort, false);
                const toPort = getPortPosition(to, conn.toPort, true);
                const path = createCurvePath(fromPort.x, fromPort.y, toPort.x, toPort.y);
                const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                pathEl.setAttribute('d', path);
                pathEl.classList.add('connection');
                pathEl.addEventListener('click', () => {
                    deleteConnection(conn.id);
                    showToast('ðŸ—‘ï¸ Connection deleted');
                });
                svg.appendChild(pathEl);
            });

            if (state.isConnecting && state.connectFromNode !== null) {
                const from = state.nodes.find(n=>n.id===state.connectFromNode);
                if (from) {
                    const fromPort = getPortPosition(from, state.connectFromPort, false);
                    const path = createCurvePath(fromPort.x, fromPort.y, state.tempConnectX, state.tempConnectY);
                    const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    tempPath.setAttribute('d', path);
                    tempPath.classList.add('temp-connection');
                    svg.appendChild(tempPath);
                }
            }

            applyTransform(svg);
        }

        function getPortPosition(node, portName, isInput) {
            const NODE_W = 220;
            const PORT_SIZE = 13;
            const HEADER_H = 38;
            const ROW_H = 30;
            let offsetY = HEADER_H + ROW_H/2;
            
            if (isInput) {
                const keys = Object.keys(node.inputs);
                const idx = keys.indexOf(portName);
                if (idx !== -1) {
                    offsetY = HEADER_H + idx * ROW_H + ROW_H/2;
                } else if (portName === 'exec' && keys.length === 0) {
                    offsetY = HEADER_H + ROW_H/2;
                }
                return { x: node.x + PORT_SIZE/2, y: node.y + offsetY };
            } else {
                const outputs = node.outputs || [];
                const idx = outputs.indexOf(portName);
                if (idx !== -1) {
                    const inputCount = Object.keys(node.inputs).length;
                    const hasExecInput = node.outputs.length > 0 && inputCount === 0 && node.type !== 'start';
                    const baseOffset = HEADER_H + (hasExecInput ? ROW_H : inputCount * ROW_H);
                    offsetY = baseOffset + idx * ROW_H + ROW_H/2;
                }
                return { x: node.x + NODE_W - PORT_SIZE/2, y: node.y + offsetY };
            }
        }

        function createCurvePath(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const c = Math.abs(dx) * 0.5;
            return `M ${x1} ${y1} C ${x1+c} ${y1}, ${x2-c} ${y2}, ${x2} ${y2}`;
        }

        function startConnection(e, nodeId, portName, isInput) {
            e.stopPropagation(); e.preventDefault();
            if (isInput) {
                const existingConn = state.connections.find(c => c.to === nodeId && c.toPort === portName);
                if (existingConn) {
                    state.isConnecting = true;
                    state.connectFromNode = existingConn.from;
                    state.connectFromPort = existingConn.fromPort;
                    state.connectPointerId = e.pointerId;
                    deleteConnection(existingConn.id);
                }
            } else {
                state.isConnecting = true;
                state.connectFromNode = nodeId;
                state.connectFromPort = portName;
                state.connectPointerId = e.pointerId;
            }
            render();
        }

        function setupEvents() {
            const canvas = document.getElementById('canvas-wrapper');
            const svg = document.getElementById('svg-layer');

            document.getElementById('btn-toggle-sidebar').addEventListener('click', () => {
                const sidebar = document.getElementById('sidebar');
                sidebar.style.display = sidebar.style.display === 'none' ? 'flex' : 'none';
            });

            document.getElementById('btn-generate').addEventListener('click', () => {
                const code = generateCode();
                document.getElementById('code-text').textContent = code;
                document.getElementById('code-panel').classList.add('visible');
                showToast('âœ… Code generated!');
            });

            document.getElementById('code-close').addEventListener('click', () => {
                document.getElementById('code-panel').classList.remove('visible');
            });

            document.getElementById('btn-download').addEventListener('click', () => {
                const code = generateCode();
                const blob = new Blob([code], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'script.do';
                a.click();
                URL.revokeObjectURL(url);
                showToast('â¬‡ï¸ Downloaded script.do');
            });

            document.getElementById('btn-load').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        parseAndLoadDo(evt.target.result, file.name);
                    };
                    reader.readAsText(file);
                }
                e.target.value = '';
            });

            document.getElementById('btn-clear').addEventListener('click', () => {
                if (confirm('Clear all nodes and connections?')) {
                    state.nodes = [{ id: 1, type: 'start', x: 80, y: 80, color: '#10b981', inputs: {}, outputs: ['exec'] }];
                    state.connections = [];
                    state.nextId = 2;
                    render();
                    showToast('ðŸ—‘ï¸ Canvas cleared');
                }
            });

            document.getElementById('btn-reset-view').addEventListener('click', () => {
                state.zoom = 1;
                state.panX = 0;
                state.panY = 0;
                document.getElementById('zoom-display').textContent = '100%';
                render();
                showToast('âŒ– View reset');
            });

            document.getElementById('btn-zoom-in').addEventListener('click', () => {
                state.zoom = Math.min(state.zoom * 1.1, 3);
                document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
                render();
            });

            document.getElementById('btn-zoom-out').addEventListener('click', () => {
                state.zoom = Math.max(state.zoom / 1.1, 0.3);
                document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
                render();
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                state.zoom = Math.max(0.3, Math.min(3, state.zoom * delta));
                document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
                render();
            });

            canvas.addEventListener('pointerdown', (e) => {
                if (e.target === canvas || e.target === svg || e.target.id === 'grid') {
                    if (state.isConnecting) {
                        state.isConnecting = false;
                        state.connectFromNode = null;
                        state.connectFromPort = null;
                        render();
                        showToast('âŒ Connection cancelled');
                        return;
                    }
                    state.isPanning = true;
                    state.panStartX = e.clientX - state.panX;
                    state.panStartY = e.clientY - state.panY;
                    canvas.classList.add('panning');
                }
            });

            // Cancel connection on right-click
            canvas.addEventListener('contextmenu', (e) => {
                if (state.isConnecting) {
                    e.preventDefault();
                    state.isConnecting = false;
                    state.connectFromNode = null;
                    state.connectFromPort = null;
                    render();
                    showToast('âŒ Connection cancelled');
                }
            });

            // Cancel connection on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && state.isConnecting) {
                    state.isConnecting = false;
                    state.connectFromNode = null;
                    state.connectFromPort = null;
                    render();
                    showToast('âŒ Connection cancelled');
                }
            });

            canvas.addEventListener('pointermove', (e) => {
                if (state.isPanning) {
                    state.panX = e.clientX - state.panStartX;
                    state.panY = e.clientY - state.panStartY;
                    render();
                } else if (state.isConnecting) {
                    const canvasRect = canvas.getBoundingClientRect();
                    state.tempConnectX = (e.clientX - canvasRect.left - state.panX) / state.zoom;
                    state.tempConnectY = (e.clientY - canvasRect.top - state.panY) / state.zoom;
                    render();
                } else if (state.isDragging && state.dragNodeId !== null) {
                    const dx = (e.clientX - state.dragStartClientX) / state.zoom;
                    const dy = (e.clientY - state.dragStartClientY) / state.zoom;
                    const node = state.nodes.find(n => n.id === state.dragNodeId);
                    if (node) {
                        node.x = state.dragNodeStartX + dx;
                        node.y = state.dragNodeStartY + dy;
                        render();
                    }
                }
            });

            canvas.addEventListener('pointerup', (e) => {
                if (state.isPanning) {
                    state.isPanning = false;
                    canvas.classList.remove('panning');
                }
                if (state.isDragging) {
                    state.isDragging = false;
                    state.dragNodeId = null;
                }
            });

            // Handle connection completion at document level to ensure it always fires
            document.addEventListener('pointerup', (e) => {
                if (state.isConnecting) {
                    e.stopPropagation(); // Prevent other handlers from interfering
                    
                    // Convert mouse position to canvas space
                    const canvas = document.getElementById('canvas-wrapper');
                    const canvasRect = canvas.getBoundingClientRect();
                    const mouseCanvasX = (e.clientX - canvasRect.left - state.panX) / state.zoom;
                    const mouseCanvasY = (e.clientY - canvasRect.top - state.panY) / state.zoom;
                    
                    let connectionMade = false;
                    const SNAP_DISTANCE = 35; // Distance in canvas pixels to snap to a port
                    
                    // Check each node's input ports
                    for (const toNode of state.nodes) {
                        if (toNode.id === state.connectFromNode) continue; // Can't connect to self
                        
                        // Check if node has inputs
                        const inputKeys = Object.keys(toNode.inputs || {});
                        const hasExecInput = toNode.outputs && toNode.outputs.length > 0 && inputKeys.length === 0 && toNode.type !== 'start';
                        
                        // Build list of input ports to check
                        const portsToCheck = [];
                        if (hasExecInput) {
                            portsToCheck.push({ name: 'exec', index: 0 });
                        } else if (inputKeys.length > 0) {
                            inputKeys.forEach((key, index) => {
                                portsToCheck.push({ name: key, index: index });
                            });
                        }
                        
                        // Check each input port
                        for (const portInfo of portsToCheck) {
                            const portPos = getPortPosition(toNode, portInfo.name, true);
                            const dx = mouseCanvasX - portPos.x;
                            const dy = mouseCanvasY - portPos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= SNAP_DISTANCE) {
                                // Remove existing connection to this port
                                const existingConn = state.connections.find(c => c.to === toNode.id && c.toPort === portInfo.name);
                                if (existingConn) {
                                    deleteConnection(existingConn.id);
                                }
                                
                                // Create new connection
                                const connId = `conn-${state.connectFromNode}-${state.connectFromPort}-${toNode.id}-${portInfo.name}`;
                                state.connections.push({
                                    id: connId,
                                    from: state.connectFromNode,
                                    fromPort: state.connectFromPort,
                                    to: toNode.id,
                                    toPort: portInfo.name
                                });
                                showToast('ðŸ”— Connection created');
                                connectionMade = true;
                                break;
                            }
                        }
                        
                        if (connectionMade) break;
                    }
                    
                    // Always clear connection state after attempting to connect
                    state.isConnecting = false;
                    state.connectFromNode = null;
                    state.connectFromPort = null;
                    render();
                }
            });

            document.getElementById('search-input').addEventListener('input', (e) => {
                renderSidebar(e.target.value);
            });

            // Drag and drop support
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                document.getElementById('drop-overlay').classList.add('active');
            });

            canvas.addEventListener('dragleave', (e) => {
                if (e.target === canvas) {
                    document.getElementById('drop-overlay').classList.remove('active');
                }
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                document.getElementById('drop-overlay').classList.remove('active');
                const file = e.dataTransfer.files[0];
                if (file && (file.name.endsWith('.do') || file.name.endsWith('.txt'))) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        parseAndLoadDo(evt.target.result, file.name);
                    };
                    reader.readAsText(file);
                } else {
                    showToast('âŒ Please drop a .do or .txt file', true);
                }
            });
        }

        function render() {
            renderNodes();
            renderConnections();
        }

        function parseScript(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));
            const parsed = [];
            
            // Find all command definitions
            const allCommands = [];
            for (const cmds of Object.values(COMMANDS)) {
                allCommands.push(...cmds);
            }

            // Quote-aware tokenizer: keeps "quoted strings" as single tokens
            function tokenize(line) {
                const tokens = [];
                let current = '';
                let inQuote = false;
                let quoteChar = '';
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (inQuote) {
                        current += ch;
                        if (ch === quoteChar) inQuote = false;
                    } else if (ch === '"' || ch === "'") {
                        inQuote = true; quoteChar = ch; current += ch;
                    } else if (ch === ' ' || ch === '\t') {
                        if (current) { tokens.push(current); current = ''; }
                    } else {
                        current += ch;
                    }
                }
                if (current) tokens.push(current);
                return tokens;
            }
            
            for (const line of lines) {
                const tokens = tokenize(line);
                const cmdName = tokens[0];

                // Handle global_variable / local_variable with " = " syntax from code generator
                if ((cmdName === 'global_variable' || cmdName === 'local_variable') && tokens[1] === '=') {
                    const val = tokens.slice(2).join(' ');
                    parsed.push({ type: cmdName, color: '#14b8a6', outputs: ['exec'], inputs: { names: val } });
                    continue;
                }
                
                // Find matching command
                const cmd = allCommands.find(c => c.name === cmdName);
                if (cmd) {
                    const node = {
                        type: cmd.name,
                        color: cmd.color,
                        outputs: cmd.outputs || [],
                        inputs: {}
                    };
                    
                    // Parse inputs with quote-aware tokens; last input captures remaining tokens
                    if (cmd.inputs && cmd.inputs.length > 0) {
                        if (cmd.inputs.length === 1) {
                            node.inputs[cmd.inputs[0]] = tokens.slice(1).join(' ');
                        } else {
                            cmd.inputs.forEach((iname, idx) => {
                                if (idx === cmd.inputs.length - 1) {
                                    node.inputs[iname] = tokens.slice(1 + idx).join(' ') || '';
                                } else {
                                    node.inputs[iname] = tokens[1 + idx] || '';
                                }
                            });
                        }
                    }
                    parsed.push(node);
                } else {
                    // Handle variable declarations and arithmetic assignments
                    if (line.includes(' = ')) {
                        const eqIdx = line.indexOf(' = ');
                        const lhs = line.slice(0, eqIdx).trim();
                        const rhs = line.slice(eqIdx + 3).trim();
                        if (lhs === 'global_variable') {
                            parsed.push({ type: 'global_variable', color: '#14b8a6', outputs: ['exec'], inputs: { names: rhs } });
                        } else if (lhs === 'local_variable') {
                            parsed.push({ type: 'local_variable', color: '#14b8a6', outputs: ['exec'], inputs: { names: rhs } });
                        } else {
                            // Detect arithmetic operator
                            let arithType = null, a = '', b = '';
                            const binOps = [
                                { op: ' ** ', type: 'pow' },
                                { op: ' // ', type: 'floordiv' },
                                { op: ' + ',  type: 'add' },
                                { op: ' - ',  type: 'sub' },
                                { op: ' * ',  type: 'mul' },
                                { op: ' / ',  type: 'div' },
                                { op: ' % ',  type: 'mod' },
                            ];
                            for (const {op, type} of binOps) {
                                const i = rhs.indexOf(op);
                                if (i !== -1) { arithType = type; a = rhs.slice(0,i).trim(); b = rhs.slice(i+op.length).trim(); break; }
                            }
                            if (!arithType && rhs.startsWith('-')) {
                                arithType = 'neg'; a = rhs.slice(1).trim();
                            }
                            if (!arithType && rhs.startsWith('abs(') && rhs.endsWith(')')) {
                                arithType = 'abs'; a = rhs.slice(4,-1).trim();
                            }
                            if (arithType) {
                                const inputs = { result: lhs, a };
                                if (b) inputs.b = b;
                                parsed.push({ type: arithType, color: '#e879f9', outputs: ['exec'], inputs });
                            } else {
                                // Generic assignment node
                                parsed.push({ type: 'set', color: '#14b8a6', outputs: ['exec'], inputs: { variable: lhs, value: rhs } });
                            }
                        }
                    }
                }
            }
            return parsed;
        }

        function parseAndLoadDo(text, filename) {
            const parsed = parseScript(text);
            const COLS=4, NODE_W=220, NODE_H=120, GAP_X=60, GAP_Y=40, ORIGIN_X=80, ORIGIN_Y=80;
            state.nodes = [{ id:1, type:'start', x:ORIGIN_X, y:ORIGIN_Y, color:'#10b981', inputs:{}, outputs:['exec'] }];
            state.connections = []; 
            state.nextId = 2;
            
            // Create nodes
            const createdNodeIds = [1];
            parsed.forEach((p, idx) => {
                const col = idx % COLS, row = Math.floor(idx / COLS);
                const x = ORIGIN_X + col * (NODE_W + GAP_X) + 320;
                const y = ORIGIN_Y + row * (NODE_H + GAP_Y);
                const nodeId = state.nextId++;
                state.nodes.push({ id: nodeId, type: p.type, x, y, color: p.color, inputs: p.inputs || {}, outputs: p.outputs || [] });
                createdNodeIds.push(nodeId);
            });
            
            // Auto-connect nodes in sequence
            for (let i = 0; i < createdNodeIds.length - 1; i++) {
                const fromId = createdNodeIds[i];
                const toId = createdNodeIds[i + 1];
                const fromNode = state.nodes.find(n => n.id === fromId);
                const toNode = state.nodes.find(n => n.id === toId);
                
                if (fromNode && toNode && fromNode.outputs && fromNode.outputs.includes('exec')) {
                    // Use same logic as manual connection to determine target port
                    const inputKeys = Object.keys(toNode.inputs || {});
                    const hasExecInput = toNode.outputs && toNode.outputs.length > 0 && inputKeys.length === 0 && toNode.type !== 'start';
                    
                    let toPort = 'exec';
                    if (hasExecInput) {
                        toPort = 'exec';
                    } else if (inputKeys.length > 0) {
                        toPort = inputKeys[0];
                    }
                    
                    const connId = `conn-${fromId}-exec-${toId}-${toPort}`;
                    state.connections.push({
                        id: connId,
                        from: fromId,
                        fromPort: 'exec',
                        to: toId,
                        toPort: toPort
                    });
                }
            }
            
            render(); 
            showToast(`âœ… Loaded "${filename}" â€” ${parsed.length} command${parsed.length!==1?'s':''} imported and connected`);
        }

        function generateCode() {
    const lines = ['# Generated by DoScript Visual IDE v0.6.5', ''];
    const visited = new Set();
    
    function traverse(node) {
        if (!node || visited.has(node.id)) return; 
        visited.add(node.id);
        
        if (node.type === 'start') {
            lines.push('# Script Start');
        } else {
            let line = node.type;
            
            // Arithmetic nodes â†’ emit as assignment
            const arithOps = {
                'add':      (r,a,b) => `${r} = ${a} + ${b}`,
                'sub':      (r,a,b) => `${r} = ${a} - ${b}`,
                'mul':      (r,a,b) => `${r} = ${a} * ${b}`,
                'div':      (r,a,b) => `${r} = ${a} / ${b}`,
                'floordiv': (r,a,b) => `${r} = ${a} // ${b}`,
                'mod':      (r,a,b) => `${r} = ${a} % ${b}`,
                'pow':      (r,a,b) => `${r} = ${a} ** ${b}`,
                'neg':      (r,a)   => `${r} = -${a}`,
                'abs':      (r,a)   => `${r} = abs(${a})`,
            };

            if (arithOps[node.type]) {
                const v = node.inputs || {};
                line = arithOps[node.type](v.result||'res', v.a||'0', v.b||'0');
            } else if (node.type === 'global_variable' || node.type === 'local_variable') {
                // Special syntax for variable declarations
                const varNames = Object.values(node.inputs || {}).filter(v => v).join(', ');
                if (varNames) {
                    line += ' = ' + varNames;
                }
            } else if (node.type === 'set') {
                // Emit as: variable = value
                line = `${(node.inputs && node.inputs.variable) || 'x'} = ${(node.inputs && node.inputs.value) || '0'}`;

            } else if (node.type === 'make file') {
                // REAL DoScript syntax:
                // make file "name" with "content"
                const p = (node.inputs && node.inputs.path) ? node.inputs.path : '"output.txt"';
                let content = (node.inputs && node.inputs.content) ? node.inputs.content : '""';

                // Auto-quote if user forgot quotes (turn unquoted text into a proper JS-style quoted string)
                if (!/^["'].*["']$/.test(content)) {
                    content = JSON.stringify(content);
                }

                line = `make file ${p} with ${content}`;

            } else if (node.type === 'download') {
                // download "url" to "path"
                const url = (node.inputs && node.inputs.url) ? node.inputs.url : '"https://example.com/file.zip"';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"download.zip"';
                line = `download ${url} to ${path}`;

            } else if (node.type === 'upload') {
                // upload "path" to "url"
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"file.txt"';
                const url = (node.inputs && node.inputs.url) ? node.inputs.url : '"https://example.com/upload"';
                line = `upload ${path} to ${url}`;

            } else if (node.type === 'copy' && node.inputs && node.inputs.src) {
                // copy "src" to "dst"
                const src = node.inputs.src || '"source.txt"';
                const dst = node.inputs.dst || '"backup.txt"';
                line = `copy ${src} to ${dst}`;

            } else if (node.type === 'move') {
                // move "src" to "dst"
                const src = (node.inputs && node.inputs.src) ? node.inputs.src : '"file.txt"';
                const dst = (node.inputs && node.inputs.dst) ? node.inputs.dst : '"archive/"';
                line = `move ${src} to ${dst}`;

            } else if (node.type === 'read') {
                // read var from "path"
                const v = (node.inputs && node.inputs.var) ? node.inputs.var : 'content';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"data.txt"';
                line = `read ${v} from ${path}`;

            } else if (node.type === 'write') {
                // write "text" to "path"
                const text = (node.inputs && node.inputs.text) ? node.inputs.text : '"Hello"';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"output.txt"';
                line = `write ${text} to ${path}`;

            } else if (node.type === 'append') {
                // append "text" to "path"
                const text = (node.inputs && node.inputs.text) ? node.inputs.text : '"New line"';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"log.txt"';
                line = `append ${text} to ${path}`;

            } else if (node.type === 'json_read') {
                // json_read var from "path"
                const v = (node.inputs && node.inputs.var) ? node.inputs.var : 'jsonData';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"data.json"';
                line = `json_read ${v} from ${path}`;

            } else if (node.type === 'json_write') {
                // json_write var to "path"
                const v = (node.inputs && node.inputs.var) ? node.inputs.var : 'jsonData';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"output.json"';
                line = `json_write ${v} to ${path}`;

            } else if (node.type === 'json_get') {
                // json_get value from var key "keyname"
                const result = (node.inputs && node.inputs.result) ? node.inputs.result : 'value';
                const v = (node.inputs && node.inputs.var) ? node.inputs.var : 'jsonData';
                const key = (node.inputs && node.inputs.key) ? node.inputs.key : '"name"';
                line = `json_get ${result} from ${v} key ${key}`;

            } else if (node.type === 'csv_read') {
                // csv_read var from "path"
                const v = (node.inputs && node.inputs.var) ? node.inputs.var : 'csvData';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"data.csv"';
                line = `csv_read ${v} from ${path}`;

            } else if (node.type === 'csv_write') {
                // csv_write var to "path"
                const v = (node.inputs && node.inputs.var) ? node.inputs.var : 'csvData';
                const path = (node.inputs && node.inputs.path) ? node.inputs.path : '"output.csv"';
                line = `csv_write ${v} to ${path}`;

            } else if (node.type === 'zip') {
                // zip "zipfile" from "source"
                const zipfile = (node.inputs && node.inputs.zipfile) ? node.inputs.zipfile : '"archive.zip"';
                const source = (node.inputs && node.inputs.source) ? node.inputs.source : '"folder"';
                line = `zip ${zipfile} from ${source}`;

            } else if (node.type === 'unzip') {
                // unzip "zipfile" to "dest"
                const zipfile = (node.inputs && node.inputs.zipfile) ? node.inputs.zipfile : '"archive.zip"';
                const dest = (node.inputs && node.inputs.dest) ? node.inputs.dest : '"extracted"';
                line = `unzip ${zipfile} to ${dest}`;

            } else {
                // Build argument list from inputs (default handler)
                const args = [];
                if (node.inputs && Object.keys(node.inputs).length > 0) {
                    Object.values(node.inputs).forEach(v => {
                        if (v === undefined || v === null || v === '') {
                            // Skip empty values
                        } else {
                            args.push(v);
                        }
                    });
                }
                
                if (args.length > 0) {
                    line += ' ' + args.join(' ');
                }
            }
            
            lines.push(line);
        }
        
        // Follow execution path
        const outgoing = state.connections.filter(c => c.from === node.id);
        outgoing.forEach(conn => {
            const nextNode = state.nodes.find(n => n.id === conn.to);
            traverse(nextNode);
        });
    }
    
    const startNode = state.nodes.find(n => n.type === 'start');
    if (startNode) {
        traverse(startNode);
    } else if (state.nodes.length > 0) {
        traverse(state.nodes[0]);
    }
    
    return lines.join('\n');
}


        // boot
        setupEvents();
        renderSidebar('');
        render();

        window.__IDE = { state, render, parseAndLoadDo };
    </script>
</body>
</html>
